/* -------------------------------------------------------
   refrigerantDiagram.js – Mitsubishi e-Solution style
   refrigerant piping diagram renderer
   Supports layouts: horizontal-tree, vertical-tree, compact-grid
------------------------------------------------------- */
import { createSvg, g, rect, line, text, path } from './svgUtils.js';
import { drawOutdoorUnit, drawIndoorUnit, drawJoint, drawRemote } from './icons.js';

export function renderRefrigerantDiagram(config, layout = 'horizontal-tree') {
    switch (layout) {
        case 'vertical-tree': return renderVerticalTree(config);
        case 'compact-grid': return renderCompactGrid(config);
        default: return renderHorizontalTree(config);
    }
}

/* ==================================================================
   SHARED HELPERS
   ================================================================== */

function drawHeader(svg, x, y, outdoorModel) {
    const hg = g(svg, `translate(${x},${y})`);
    // Brand bar
    rect(hg, 0, 0, 180, 14, { fill: '#cc0000', stroke: 'none' });
    text(hg, 4, 10, 'HVAC DIAGRAMS', { fontSize: 8, fill: '#fff', fontWeight: '700' });
    text(hg, 60, 10, 'Generated by HVAC Diagram Generator', { fontSize: 6, fill: '#fff' });
    // e-solution style label
    rect(hg, 0, 16, 90, 12, { fill: '#003399', stroke: 'none' });
    text(hg, 4, 25, 'e-solution', { fontSize: 8, fill: '#fff', fontWeight: '600' });
    // Model
    text(hg, 0, 42, outdoorModel || '', { fontSize: 9, fill: '#333', fontWeight: '600' });
}

function drawProjectInfoBox(svg, x, y, project, n) {
    const ig = g(svg, `translate(${x},${y})`);
    const lines = [
        { label: 'Proyecto', value: project.name || 'HVAC PROJECT', bold: true },
        { label: 'Referencia proy', value: '' },
        { label: 'Sistema', value: project.system || 'UE1' },
        { label: 'Condiciones de diseño', value: project.designConditions || '' },
        { label: 'Tirada total de tubería', value: `${project.totalPipeLength || 0} m  de  ${project.maxPipeLength || 0} m` },
        { label: 'Unidades interiores conectadas totales', value: String(n) },
        { label: 'Capacidad en frío real total', value: `${project.totalCooling || 0} kW / ${project.totalHeating || 0} kW` },
        { label: 'Capacidad en frío total requerida', value: `${project.requiredCooling || 0} kW / ${project.requiredHeating || 0} kW` },
        { label: 'Capacidad conectada', value: project.connectedCapacity || '' },
        { label: 'Factor diversidad', value: project.diversityFactor || '0%' },
        { label: 'Refrigerante adicional', value: `${project.additionalRefrigerant || 0} kg` },
        { label: 'Cantidad total de refrigerante', value: `${project.totalRefrigerant || 0} kg` },
    ];
    lines.forEach((l, i) => {
        const yy = i * 14;
        text(ig, 0, yy, `${l.label} : `, { fontSize: 9, fill: '#333' });
        text(ig, 200, yy, l.value, {
            fontSize: 9,
            fill: l.bold ? '#003399' : '#333',
            fontWeight: l.bold ? '700' : '400',
        });
    });
}

/**
 * Draw a pipe segment with size labels and distance.
 * Horizontal segment from (x1,y) to (x2,y).
 */
function drawPipeH(svg, x1, y, x2, opts = {}) {
    line(svg, x1, y, x2, y, { stroke: '#333', strokeWidth: 1.2 });
    const labelX = (x1 + x2) / 2;
    if (opts.gasSize) {
        text(svg, labelX, y - 8, `${opts.gasSize}, ${opts.liquidSize || ''}`, {
            fontSize: 8, fill: '#333', anchor: 'middle',
        });
    }
    if (opts.distance !== undefined) {
        text(svg, labelX, y + 12, `${opts.distance}m`, {
            fontSize: 8, fill: '#009900', anchor: 'middle', fontWeight: '500',
        });
    }
}

/**
 * Draw a vertical pipe segment from (x,y1) to (x,y2).
 */
function drawPipeV(svg, x, y1, y2) {
    line(svg, x, y1, x, y2, { stroke: '#333', strokeWidth: 1.2 });
}

/**
 * Draw a complete indoor unit block with all labels, matching the reference.
 * Returns the block height.
 */
function drawUnitBlock(svg, x, y, unit) {
    const ug = g(svg, `translate(${x},${y})`);

    // Dashed border box around unit area
    rect(ug, -10, -35, 180, 110, { fill: 'none', stroke: '#999', strokeWidth: 0.6, strokeDash: '4,3' });

    // Capacity labels above unit (green/orange)
    text(ug, 0, -22, `${unit.cooling_kw} kW/${unit.heating_kw} kW`, {
        fontSize: 9, fill: '#006600', fontWeight: '600',
    });
    // Model label (blue)
    text(ug, 0, -10, `${unit.index}. ${unit.model}`, {
        fontSize: 8, fill: '#0066cc', fontWeight: '500',
    });

    // Actual capacity (right side, blue)
    text(ug, 120, -22, '0.00 kW/0.00 kW', { fontSize: 8, fill: '#0066cc' });

    // Indoor unit icon
    drawIndoorUnit(ug, 30, 0, unit.type);

    // Room name below (blue bold)
    text(ug, 56, 62, `${unit.room} ${unit.location}`, {
        fontSize: 9, fill: '#003399', anchor: 'middle', fontWeight: '600',
    });

    return ug;
}


/* ==================================================================
   LAYOUT 1: HORIZONTAL TREE (matches reference exactly)
   Outdoor unit left → tree branches right/down → indoor units on right
   ================================================================== */

function renderHorizontalTree(config) {
    const units = config.indoor || [];
    const piping = config.piping || {};  // Now a tree object
    const project = config.project || {};
    const outdoor = config.outdoor || {};
    const n = units.length;

    // Count leaf nodes to determine SVG height
    const ROW_HEIGHT = 140;
    const LEFT_MARGIN = 40;
    const TOP_MARGIN = 70;

    const svgH = Math.max(600, TOP_MARGIN + n * ROW_HEIGHT + 80);
    const svgW = Math.max(1050, 1050);
    const svg = createSvg(svgW, svgH);
    rect(svg, 0, 0, svgW, svgH, { fill: '#ffffff', stroke: 'none' });

    // Header (top-left)
    drawHeader(svg, LEFT_MARGIN, 10, outdoor.model);

    // Project info (top-right)
    drawProjectInfoBox(svg, svgW - 440, 10, project, n);

    // Outdoor unit
    const ouX = LEFT_MARGIN, ouY = TOP_MARGIN + 40;
    drawOutdoorUnit(svg, ouX, ouY, outdoor.model);

    // Model label below outdoor
    text(svg, ouX + 50, ouY + 100, outdoor.model || '', {
        fontSize: 9, fill: '#003399', anchor: 'middle', fontWeight: '600',
    });

    // Starting point for piping (right edge of outdoor unit)
    const pipeStartX = ouX + 103;
    const pipeStartY = ouY + 35;

    // Recursively draw the piping tree
    let unitRow = 0;
    const UNIT_X = svgW - 230; // X position for indoor units (right side)
    const firstUnitY = TOP_MARGIN + 20;

    function drawTreeNode(node, startX, startY, depth) {
        if (!node) return startY;

        // Is this a leaf node (has a unit)?
        if (node.unit) {
            const unitY = firstUnitY + unitRow * ROW_HEIGHT;
            // Draw horizontal pipe to unit
            drawPipeH(svg, startX, startY, UNIT_X - 20, {
                gasSize: node.gasSize,
                liquidSize: node.liquidSize,
                distance: node.distance,
            });
            // Vertical adjustment if startY != unitY
            if (Math.abs(startY - (unitY + 25)) > 5) {
                // Route: horizontal stub, vertical, horizontal to unit
                const midX = startX + 50;
                // Clear previous horizontal line by overdrawing
            }
            // Connect to unit with a small horizontal stub
            line(svg, UNIT_X - 20, startY, UNIT_X - 20, unitY + 25, { stroke: '#333', strokeWidth: 1.2 });
            line(svg, UNIT_X - 20, unitY + 25, UNIT_X, unitY + 25, { stroke: '#333', strokeWidth: 1.2 });

            // Draw unit block
            drawUnitBlock(svg, UNIT_X, unitY, node.unit);

            // Draw remote controller (far right)
            drawRemote(svg, UNIT_X + 190, unitY + 5, node.unit.remote || 'RC-EX3A');

            unitRow++;
            return unitY + 25;
        }

        // Internal node (joint with children)
        if (node.children && node.children.length > 0) {
            // Draw horizontal pipe from start to joint position
            const jointX = startX + 80 + Math.min(depth * 20, 60);

            drawPipeH(svg, startX, startY, jointX, {
                gasSize: node.gasSize,
                liquidSize: node.liquidSize,
                distance: node.distance,
            });

            // Draw joint symbol
            drawJoint(svg, jointX, startY, node.joint);

            // Draw children
            // First child continues horizontally (right)
            // Second child goes down then right
            const childStartX = jointX + 10;

            if (node.children.length === 1) {
                return drawTreeNode(node.children[0], childStartX, startY, depth + 1);
            }

            // First child — continues at same Y
            const firstChildEndY = drawTreeNode(node.children[0], childStartX, startY, depth + 1);

            // Calculate where second child should start
            // Count leaves in first child to know the Y offset
            const firstChildLeaves = countLeaves(node.children[0]);
            const secondChildStartY = firstUnitY + (unitRow) * ROW_HEIGHT + 25;

            // Vertical pipe from joint down to second child
            drawPipeV(svg, jointX, startY, secondChildStartY);

            // Second child — starts at lower Y
            const secondChildEndY = drawTreeNode(node.children[1], jointX + 10, secondChildStartY, depth + 1);

            return secondChildEndY;
        }

        return startY;
    }

    function countLeaves(node) {
        if (!node) return 0;
        if (node.unit) return 1;
        if (!node.children) return 0;
        return node.children.reduce((s, c) => s + countLeaves(c), 0);
    }

    // Draw the tree starting from the outdoor unit pipe connection
    drawTreeNode(piping, pipeStartX, pipeStartY, 0);

    return svg;
}


/* ==================================================================
   LAYOUT 2: VERTICAL TREE
   Outdoor at top, tree expands downward and sideways
   ================================================================== */

function renderVerticalTree(config) {
    const units = config.indoor || [];
    const piping = config.piping || {};
    const project = config.project || {};
    const outdoor = config.outdoor || {};
    const n = units.length;
    const COL_WIDTH = 210;

    const svgW = Math.max(900, 120 + n * COL_WIDTH);
    const svgH = Math.max(700, 700);
    const svg = createSvg(svgW, svgH);
    rect(svg, 0, 0, svgW, svgH, { fill: '#ffffff', stroke: 'none' });

    drawHeader(svg, 30, 10, outdoor.model);
    drawProjectInfoBox(svg, svgW - 440, 10, project, n);

    const ouX = svgW / 2 - 50, ouY = 60;
    drawOutdoorUnit(svg, ouX, ouY, outdoor.model);
    text(svg, ouX + 50, ouY + 100, outdoor.model || '', {
        fontSize: 9, fill: '#003399', anchor: 'middle', fontWeight: '600',
    });

    const pipeStartX = ouX + 50, pipeStartY = ouY + 90;
    let unitCol = 0;
    const UNIT_Y = svgH - 200;
    const firstUnitX = (svgW - (n - 1) * COL_WIDTH) / 2;

    function drawVTree(node, toX, toY, depth) {
        if (!node) return;

        if (node.unit) {
            const ux = firstUnitX + unitCol * COL_WIDTH;
            line(svg, toX, toY, ux + 28, toY, { stroke: '#333', strokeWidth: 1.2 });
            line(svg, ux + 28, toY, ux + 28, UNIT_Y, { stroke: '#333', strokeWidth: 1.2 });
            text(svg, ux + 35, (toY + UNIT_Y) / 2, `${node.distance}m`, {
                fontSize: 8, fill: '#009900',
            });
            drawUnitBlock(svg, ux, UNIT_Y, node.unit);
            drawRemote(svg, ux + 10, UNIT_Y + 80, node.unit.remote || 'RC-EX3A');
            unitCol++;
            return;
        }

        if (node.children && node.children.length > 0) {
            const jointY = toY + 60;
            line(svg, toX, toY, toX, jointY, { stroke: '#333', strokeWidth: 1.2 });
            text(svg, toX + 5, (toY + jointY) / 2, `${node.gasSize}, ${node.liquidSize}`, {
                fontSize: 7, fill: '#333',
            });
            text(svg, toX + 5, (toY + jointY) / 2 + 10, `${node.distance}m`, {
                fontSize: 7, fill: '#009900',
            });
            drawJoint(svg, toX, jointY, node.joint);

            const leavesLeft = countLeavesV(node.children[0]);
            const leavesRight = node.children[1] ? countLeavesV(node.children[1]) : 0;
            const leftCenter = firstUnitX + (unitCol + (leavesLeft - 1) / 2) * COL_WIDTH + 28;
            const rightCenter = firstUnitX + (unitCol + leavesLeft + (leavesRight - 1) / 2) * COL_WIDTH + 28;

            line(svg, toX, jointY, leftCenter, jointY, { stroke: '#333', strokeWidth: 1.2 });
            drawVTree(node.children[0], leftCenter, jointY, depth + 1);

            if (node.children[1]) {
                line(svg, toX, jointY, rightCenter, jointY, { stroke: '#333', strokeWidth: 1.2 });
                drawVTree(node.children[1], rightCenter, jointY, depth + 1);
            }
        }
    }

    function countLeavesV(node) {
        if (!node) return 0;
        if (node.unit) return 1;
        if (!node.children) return 0;
        return node.children.reduce((s, c) => s + countLeavesV(c), 0);
    }

    line(svg, pipeStartX, pipeStartY, pipeStartX, pipeStartY + 20, { stroke: '#333', strokeWidth: 1.5 });
    drawVTree(piping, pipeStartX, pipeStartY + 20, 0);

    return svg;
}


/* ==================================================================
   LAYOUT 3: COMPACT GRID
   Outdoor top-left, units in a grid below a distribution bus
   ================================================================== */

function renderCompactGrid(config) {
    const units = config.indoor || [];
    const piping = config.piping || {};
    const project = config.project || {};
    const outdoor = config.outdoor || {};
    const n = units.length;
    const COLS = Math.min(n, Math.max(2, Math.ceil(Math.sqrt(n))));
    const ROWS = Math.ceil(n / COLS);
    const CELL_W = 220, CELL_H = 150;

    const gridW = COLS * CELL_W;
    const svgW = Math.max(950, 80 + gridW + 80);
    const svgH = Math.max(600, 230 + ROWS * CELL_H + 40);
    const svg = createSvg(svgW, svgH);
    rect(svg, 0, 0, svgW, svgH, { fill: '#ffffff', stroke: 'none' });

    drawHeader(svg, 30, 10, outdoor.model);
    drawProjectInfoBox(svg, svgW - 440, 10, project, n);

    const ouX = 30, ouY = 60;
    drawOutdoorUnit(svg, ouX, ouY, outdoor.model);
    text(svg, ouX + 50, ouY + 100, outdoor.model || '', {
        fontSize: 9, fill: '#003399', anchor: 'middle', fontWeight: '600',
    });

    const trunkY = ouY + 35;
    const gridStartX = 80;
    const gridStartY = ouY + 180;

    // Main trunk pipe
    line(svg, ouX + 103, trunkY, gridStartX + gridW / 2, trunkY, { stroke: '#333', strokeWidth: 1.5 });
    if (piping.gasSize) {
        text(svg, ouX + 160, trunkY - 8, `${piping.gasSize}, ${piping.liquidSize}`, {
            fontSize: 8, fill: '#333',
        });
        text(svg, ouX + 160, trunkY + 12, `${piping.distance}m`, {
            fontSize: 8, fill: '#009900',
        });
    }

    // Vertical trunk down
    line(svg, gridStartX + gridW / 2, trunkY, gridStartX + gridW / 2, gridStartY - 20, {
        stroke: '#333', strokeWidth: 1.5,
    });
    // Horizontal distribution line
    line(svg, gridStartX, gridStartY - 20, gridStartX + gridW, gridStartY - 20, {
        stroke: '#333', strokeWidth: 1.2,
    });

    // Flatten the tree to get units in order
    const flatUnits = flattenTree(piping);
    const drawUnits = flatUnits.length > 0 ? flatUnits : units;

    drawUnits.forEach((u, i) => {
        const col = i % COLS, row = Math.floor(i / COLS);
        const cx = gridStartX + col * CELL_W + CELL_W / 2;
        const uy = gridStartY + row * CELL_H;

        // Drop from distribution
        line(svg, cx, gridStartY - 20, cx, uy - 10, { stroke: '#333', strokeWidth: 1 });
        drawJoint(svg, cx, gridStartY - 20, '');

        // Unit block (simplified for grid)
        const ug = g(svg, `translate(${cx - 30},${uy})`);
        drawIndoorUnit(ug, 0, 0, u.type);
        text(ug, 28, -10, `${u.cooling_kw}/${u.heating_kw} kW`, {
            fontSize: 8, fill: '#006600', anchor: 'middle', fontWeight: '600',
        });
        text(ug, 28, 60, `${u.index}. ${u.model}`, {
            fontSize: 7, fill: '#333', anchor: 'middle',
        });
        text(ug, 28, 72, u.room || '', {
            fontSize: 8, fill: '#003399', anchor: 'middle', fontWeight: '600',
        });
    });

    return svg;
}

function flattenTree(node) {
    if (!node) return [];
    if (node.unit) return [node.unit];
    if (!node.children) return [];
    return node.children.flatMap(c => flattenTree(c));
}
